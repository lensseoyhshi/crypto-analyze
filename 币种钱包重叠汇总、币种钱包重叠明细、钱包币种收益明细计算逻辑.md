币种钱包重叠汇总、币种钱包重叠明细、钱包币种收益明细 计算逻辑：

---

## 第一步：数据从哪来

三个 sheet 共享同一份底层数据，来源是 `birdeye_wallet_transactions` 表。

```558:563:analyze_wallet_snapshot.py
            sql = text(f"""
                SELECT `from`, block_time, side, balance_change
                FROM birdeye_wallet_transactions
                WHERE `from` IN ({in_clause})
                  AND side IN ('buy', 'sell')
                ORDER BY block_time ASC
            """)
```

查出所有非高频钱包的 buy/sell 交易记录，每条记录包含：
- `from` — 钱包地址
- `block_time` — 链上交易时间
- `side` — "buy" 或 "sell"
- `balance_change` — **JSON 字符串**，记录这笔交易中各 token 的数量变化

## 第二步：解析 balance_change JSON

`balance_change` 是一个 JSON 数组，通常有 2 个元素，例如一笔买入交易：

```json
[
  {"symbol": "SOL", "amount": -150000000, "decimals": 9, "address": "So11..."},
  {"symbol": "BONK", "amount": 5000000000, "decimals": 5, "address": "DezX..."}
]
```

`parse_balance_change` 函数做的事：

```498:537:analyze_wallet_snapshot.py
    quote_total = 0.0
    token_info = None

    for item in bc:
        symbol = item.get('symbol', '')
        name = item.get('name', '')
        raw_amount = item.get('amount', 0)
        decimals = item.get('decimals', 0)
        address = item.get('address', '')

        # 转换为人类可读金额
        if decimals and decimals > 0:
            amount = raw_amount / (10 ** decimals)
        else:
            amount = raw_amount

        is_quote = (symbol in QUOTE_TOKENS or name in QUOTE_TOKENS)

        if is_quote:
            quote_total += amount
        else:
            # 保留绝对值最大的代币
            if token_info is None or abs(amount) > abs(token_info['amount']):
                token_info = {
                    'symbol': symbol or name or 'UNKNOWN',
                    'name': name,
                    'address': address,
                    'amount': amount,
                }

    if token_info is None:
        return None

    return {
        'quote_amount': quote_total,
        'token_symbol': token_info['symbol'],
        'token_name': token_info['name'],
        'token_address': token_info['address'],
        'token_amount': token_info['amount'],
    }
```

逐步拆解：

1. **遍历 JSON 数组中的每个 item**
2. **金额转换**：`raw_amount / (10 ^ decimals)` 把链上原始整数转为人类可读。例如 SOL 的 decimals=9，`-150000000 / 10^9 = -0.15 SOL`
3. **区分 quote token 和目标 token**：symbol 在 `{'SOL', 'USDC', 'USDT', 'Wrapped SOL', 'WSOL'}` 中的是 quote token（计价币），其余是目标 meme 币
4. **quote_total**：累加所有 quote token 的金额。买入时 SOL 减少所以是负数（如 -0.15），卖出时 SOL 增加所以是正数（如 +0.3）
5. **token_info**：如果有多个非 quote token，保留**绝对值最大**的那个（避免小额 dust token 干扰）
6. **丢弃无法解析的记录**：JSON 格式不对、不含 2 个元素、或者找不到目标 token 的都返回 None，不进入后续计算

解析完之后，每条有效交易变成：

```
{address, block_time, side, quote_amount, token_symbol, token_address, token_amount}
```

---

## 第三步：钱包币种收益明细（detail_df 的生成）

这是**核心计算**，其他两个 sheet 都是从这里派生的。

```626:689:analyze_wallet_snapshot.py
    grouped = trades_df.groupby(['address', 'token_address'])
    // ...
    for (address, token_address), group in grouped:
        buys = group[group['side'] == 'buy'].sort_values('block_time')
        sells = group[group['side'] == 'sell'].sort_values('block_time')

        if buys.empty:
            continue

        first_buy_time = buys.iloc[0]['block_time']
        token_symbol = buys.iloc[0]['token_symbol']

        # 成本：买入时 quote_amount 为负，取绝对值之和
        total_cost = abs(buys['quote_amount'].sum())
        if total_cost == 0:
            continue

        # 收入：卖出时 quote_amount 为正
        total_revenue = sells['quote_amount'].sum() if not sells.empty else 0
        total_return = (total_revenue - total_cost) / total_cost * 100
        // ...
        # 不同时间窗口的收益率
        for wname, wdelta in time_windows:
            w_end = first_buy_time + wdelta

            w_buys = buys[buys['block_time'] <= w_end]
            w_sells = sells[sells['block_time'] <= w_end]

            w_cost = abs(w_buys['quote_amount'].sum())
            w_rev = w_sells['quote_amount'].sum() if not w_sells.empty else 0

            if w_cost > 0:
                w_ret = (w_rev - w_cost) / w_cost * 100
            else:
                w_ret = 0.0
```

详细逻辑：

### 分组

按 `(钱包地址, 代币地址)` 做 groupby。同一个钱包买卖同一个币的所有交易归为一组。

### 拆分买卖

在每组内，把交易按 side 拆成 `buys`（买入记录）和 `sells`（卖出记录），各自按时间排序。

### 过滤

- **没有买入记录** → 跳过（只有卖出没有买入，无法算成本）
- **买入成本为 0** → 跳过（可能是空投或异常数据）

### 总收益率计算

以钱包 A 买卖 BONK 为例：

| 时间 | side | quote_amount (SOL) |
|---|---|---|
| 10:00 | buy | -0.5（花了0.5 SOL） |
| 10:30 | buy | -0.3（又花了0.3 SOL） |
| 11:00 | sell | +0.6（卖回0.6 SOL） |
| 15:00 | sell | +0.4（又卖回0.4 SOL） |

- `total_cost = abs((-0.5) + (-0.3)) = abs(-0.8) = 0.8 SOL`
- `total_revenue = 0.6 + 0.4 = 1.0 SOL`
- `total_return = (1.0 - 0.8) / 0.8 × 100 = 25%`

**注意**：买入时 `quote_amount` 是负数（SOL 减少了），所以 `buys['quote_amount'].sum()` 得到的是负数，再取 `abs()` 就是总成本。卖出时 `quote_amount` 是正数（SOL 增加了），直接求和就是总收入。

### 时间窗口收益率

以**首次买入时间**为基准，向后推 1小时/6小时/24小时/3天/7天/30天，只统计该窗口内的买卖：

还是上面的例子，首次买入 10:00：

**1小时窗口**（10:00 ~ 11:00）：
- 窗口内买入：10:00 的 -0.5 + 10:30 的 -0.3 → cost = 0.8
- 窗口内卖出：11:00 的 +0.6 → rev = 0.6
- 1小时收益率 = (0.6 - 0.8) / 0.8 × 100 = **-25%**

**6小时窗口**（10:00 ~ 16:00）：
- 窗口内买入：全部 → cost = 0.8
- 窗口内卖出：全部 → rev = 1.0
- 6小时收益率 = (1.0 - 0.8) / 0.8 × 100 = **25%**

### 最终输出的每行

```
钱包地址, 代币符号, 代币地址, 首次买入时间, 买入总成本, 卖出总收入, 买入次数, 卖出次数, 总收益率(%), 1小时_收益率(%), 6小时_收益率(%), 24小时_收益率(%), 3天_收益率(%), 7天_收益率(%), 30天_收益率(%)
```

---

## 第四步：币种钱包重叠汇总

这个 sheet 的输入就是上面的 `detail_df`，换一个视角——**从代币维度看**。

```873:916:analyze_wallet_snapshot.py
    # 按代币分组
    token_groups = detail_df.groupby(['代币地址', '代币符号'])

    summary_rows = []
    detail_rows = []

    for (token_addr, token_symbol), group in token_groups:
        wallets = group['钱包地址'].unique()
        n_wallets = len(wallets)

        wallet_names = [name_map.get(w, '') for w in wallets]
        wallet_names_clean = [n for n in wallet_names if n]

        summary_rows.append({
            '代币符号': token_symbol,
            '代币地址': token_addr,
            '买入钱包数': n_wallets,
            '钱包名称列表': ', '.join(wallet_names_clean) if wallet_names_clean else '',
            '钱包地址列表': ', '.join(wallets),
            '总买入成本(SOL)': round(group['买入总成本'].sum(), 6),
            '总卖出收入(SOL)': round(group['卖出总收入'].sum(), 6),
            '总盈亏(SOL)': round(group['卖出总收入'].sum() - group['买入总成本'].sum(), 6),
        })
```

详细逻辑：

1. **按 `(代币地址, 代币符号)` 分组**——把同一个代币的所有行（来自不同钱包）归到一起
2. **买入钱包数**：该代币下有多少个**不同的钱包地址** → `group['钱包地址'].unique()` 的长度
3. **钱包名称/地址列表**：把所有钱包的名称和地址用逗号拼成字符串
4. **总买入成本(SOL)**：所有钱包在该代币上 `买入总成本` 的 `sum()`
5. **总卖出收入(SOL)**：所有钱包在该代币上 `卖出总收入` 的 `sum()`
6. **总盈亏(SOL)**：`总卖出收入 - 总买入成本`
7. **排序**：按**买入钱包数降序**，最多钱包共同买入的币排最前面

举例，detail_df 中关于 BONK 的行：

| 钱包 | 代币 | 买入总成本 | 卖出总收入 |
|---|---|---|---|
| 钱包A | BONK | 0.8 | 1.0 |
| 钱包B | BONK | 1.5 | 2.0 |
| 钱包C | BONK | 0.3 | 0.1 |

汇总得到一行：
- 代币符号 = BONK
- 买入钱包数 = 3
- 钱包名称列表 = "Alice, Bob, Charlie"
- 总买入成本 = 0.8 + 1.5 + 0.3 = 2.6 SOL
- 总卖出收入 = 1.0 + 2.0 + 0.1 = 3.1 SOL
- 总盈亏 = 3.1 - 2.6 = 0.5 SOL

---

## 第五步：币种钱包重叠明细

和汇总用的是**同一个循环**，只是展开到每个钱包：

```897:912:analyze_wallet_snapshot.py
        # 明细：每个钱包一行
        for _, row in group.iterrows():
            addr = row['钱包地址']
            detail_rows.append({
                '代币符号': token_symbol,
                '代币地址': token_addr,
                '买入钱包数(该币)': n_wallets,
                '钱包地址': addr,
                '钱包名称': name_map.get(addr, ''),
                '首次买入时间': row['首次买入时间'],
                '买入总成本(SOL)': row['买入总成本'],
                '卖出总收入(SOL)': row['卖出总收入'],
                '买入次数': row['买入次数'],
                '卖出次数': row['卖出次数'],
                '总收益率(%)': row['总收益率(%)'],
            })
```

详细逻辑：

1. 在代币分组内，**遍历每一行**（每行是一个钱包对该代币的记录）
2. **买入钱包数(该币)**：冗余字段，就是上面汇总表算出的该代币被几个钱包买入，直接带过来方便在 Excel 中筛选
3. **其他字段**直接从 `detail_df` 的对应行取值，**不做任何二次计算**
4. **排序**：先按 `买入钱包数降序`，再按 `代币符号升序`，再按 `首次买入时间升序`

还是 BONK 的例子，展开成 3 行：

| 代币 | 买入钱包数 | 钱包 | 首次买入时间 | 买入成本 | 卖出收入 | 收益率 |
|---|---|---|---|---|---|---|
| BONK | 3 | 钱包A | 02-03 10:00 | 0.8 | 1.0 | 25% |
| BONK | 3 | 钱包B | 02-03 10:15 | 1.5 | 2.0 | 33.3% |
| BONK | 3 | 钱包C | 02-04 09:00 | 0.3 | 0.1 | -66.7% |

---

## 三个 sheet 的关系总结

```
birdeye_wallet_transactions（原始交易流水）
        │
        ▼ parse_balance_change() 解析 JSON
        │
        ▼ groupby(钱包, 代币) → 算成本/收入/收益率
        │
    ┌───┴───────────────────────────┐
    ▼                               ▼
 钱包币种收益明细            groupby(代币)
 (detail_df)              ┌────────┴────────┐
 每行=一个钱包+一个币       ▼                ▼
 视角: 钱包维度         币种钱包重叠汇总    币种钱包重叠明细
                      每行=一个币         每行=一个币+一个钱包
                      视角: 币种维度       视角: 币种维度展开
```

- **钱包币种收益明细**：最细粒度，一行一个 `(钱包, 币种)` 组合，包含所有收益率
- **币种钱包重叠汇总**：对明细按**代币维度**聚合，一行一个币，告诉你"这个币有几个钱包买了，合计赚了多少"
- **币种钱包重叠明细**：对明细按**代币维度**重新排列但不聚合，一行还是一个 `(币种, 钱包)`，但排序以代币为主，且带上 `买入钱包数` 方便筛选共同买入的币